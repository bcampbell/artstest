#!/usr/bin/env python
""" compare

Compare output from a news article scraper against expected data.

The .expected data files are designed to be easy to edit by hand.
They begin with a yaml front-matter section, then the rest
of the file is the text content that we expect to be extracted.
For now, we expect the scraper to produce that same format, ready to
be passed into this program.
"""


from __future__ import print_function
import yaml
import re
import sys
from pprint import pprint
import argparse     # >=python 2.7
import unicodedata
import lxml.html
import lxml.etree

splitter = re.compile(r'---(.*?)---\s*(.*)$',re.DOTALL)

ALL_CHECKS = ['headline','urls','dates','content','authors']

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('got', help='file containing scraped data')
    parser.add_argument('expected', help='file containing expected data')


    parser.add_argument('-c', '--check',
        action='append',
        help="only check specified fields",
        choices=ALL_CHECKS)
#    parser.add_argument("-v", "--verbose", help="increase output verbosity",
#                    action="store_true")
    args = parser.parse_args()


    try:
        # load and compare two articles
        art_got = Article(args.got)
        art_expected = Article(args.expected)


        checks = ALL_CHECKS
        if args.check:
            checks = args.check

        errs = art_got.compare(art_expected, checks)
        if len(errs)>0:
            [print("  %s" % (err.encode('utf-8'),), file=sys.stdout) for err in errs]

            return 1
        else:
            return 0

    except BaseException as e:
        print("error: %s" % (e,), file=sys.stderr)
        raise
        return 2


class Article:
    def __init__(self, filename): 
        self.filename=filename
        f = open(filename,"r")
        with f:
            data = f.read()
            # split yaml front matter from content block
            m = splitter.match(data)
            assert(m)
            meta = yaml.load(m.group(1))
            for f in ("headline","published","updated","authors","canonical_url","urls"):
                if f in meta:
                    self.__dict__[f] = meta[f]
                else:
                    if f in ("authors","urls"):
                        self.__dict__[f] = []
                    else:
                        self.__dict__[f] = None

            # some patchups
            if self.urls is None:
                self.urls = []

            self.content = m.group(2)

    def dump(self):
        print("canonical_url: %s" % (self.canonical_url))
        print("headline: %s" % (self.headline))
        print("published: %s" % (self.published))
        print("updated: %s" % (self.updated))
        print("authors: %s" % (self.authors))
        print("------")
        print(self.content)

    def compare(self,expected, checks=ALL_CHECKS):

        errs = []

        # check urls
        if 'urls' in checks:
            if self.canonical_url != expected.canonical_url:
                errs.append("canonical_url: expected '%s', got '%s'" %(expected.canonical_url,self.canonical_url))
            if sorted(self.urls) != sorted(expected.urls):
                errs.append("urls: expected '%s', got '%s'" %(expected.urls,self.urls))

        # check headline
        if 'headline' in checks:
            if self.headline != expected.headline:
                errs.append("Headline: expected '%s', got '%s'" %(expected.headline,self.headline))

        # check authors
        if 'authors' in checks:
            for author in expected.authors:
                if self.find_author(author) is None:
                    errs.append("missing author: '%s'" % (author['name'],))
            for author in self.authors:
                if expected.find_author(author) is None:
                    errs.append("extra author: '%s'" % (author['name'],))

        # check content
        if 'content' in checks:
            txt1 = html_to_text(self.content)
            txt2 = html_to_text(expected.content)

            txt1 = normalise_text(txt1)
            txt2 = normalise_text(txt2)

            if txt1 != txt2:

                # is the expected stuff there?
                parts = txt1.partition(txt2)
                if len(parts[2])>0:
                    # yes, expected result is contained
                    errs.append("content mismatch - %.1f%% cruft (%d before, %d after)" % ((len(parts[0])+len(parts[2]))/float(len(txt1)), len(parts[0]), len(parts[2])))
                else:
                    errs.append("content mismatch")


        # TODO: everything else :-)

        return errs

    def find_author(self,author):
        for a in self.authors:
            if a['name'] == author['name']:
                return a
        return None



def normalise_text(txt):
    """ return stripped-down, ascii, alphanumeric-only version for comparisons """
    # replace various accented latin chars with rough ascii equivalents
    txt = unicodedata.normalize('NFKD',txt).encode('ascii','ignore')
    txt = re.sub(u'[^a-zA-Z0-9 ]',u'',txt)
    txt = u' '.join(txt.split())    # compress spaces
    txt = txt.lower().strip()
    return txt


def uberstrip(s):
    # strip leading/trailing non-alphabetic chars
    pat = re.compile(r'^[^\w()]*(.*?)[^\w()]*$', re.IGNORECASE|re.UNICODE)
    return pat.sub(r'\1', s)


def html_to_text(html):
    parser = lxml.html.HTMLParser()
    doc = lxml.html.document_fromstring(html, parser)
    return render_text(doc)




def render_text(el):
    """ like lxml.html text_content(), but with tactical use of whitespace for block elements """

    inline_tags = ( 'a', 'abbr', 'acronym', 'b', 'basefont', 'bdo', 'big',
        'br',
        'cite', 'code', 'dfn', 'em', 'font', 'i', 'img', 'input',
        'kbd', 'label', 'q', 's', 'samp', 'select', 'small', 'span',
        'strike', 'strong', 'sub', 'sup', 'textarea', 'tt', 'u', 'var',
        'applet', 'button', 'del', 'iframe', 'ins', 'map', 'object',
        'script' )

    txt = u''

    tag = str(el.tag).lower()
    if tag not in inline_tags:
        txt += u"\n";

    if el.text is not None:
        txt += unicode(el.text)
    for child in el.iterchildren():
        txt += render_text(child)
        if child.tail is not None:
            txt += unicode(child.tail)

    if el.tag=='br' or tag not in inline_tags:
        txt += u"\n";
    return txt


if __name__ == "__main__":
    sys.exit(main())

