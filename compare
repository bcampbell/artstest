#!/usr/bin/env python
""" compare

Compare output from a news article scraper against expected data.

The .expected data files are designed to be easy to edit by hand.
They begin with a yaml front-matter section, then the rest
of the file is the text content that we expect to be extracted.
For now, we expect the scraper to produce that same format, ready to
be passed into this program.
"""


from __future__ import print_function
import yaml
import re
import sys
from pprint import pprint
import argparse     # >=python 2.7

splitter = re.compile(r'---(.*?)---\s*(.*)$',re.DOTALL)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('got', help='file containing scraped data')
    parser.add_argument('expected', help='file containing expected data')
#    parser.add_argument("-v", "--verbose", help="increase output verbosity",
#                    action="store_true")
    args = parser.parse_args()


    try:
        # load and compare two articles
        art_got = Article(args.got)
        art_expected = Article(args.expected)

        errs = art_got.compare(art_expected)
        if len(errs)>0:
            [print("  %s" % (err.encode('utf-8'),), file=sys.stdout) for err in errs]

            return 1
        else:
            return 0

    except BaseException as e:
        print("error: %s" % (e,), file=sys.stderr)
        raise
        return 2


class Article:
    def __init__(self, filename): 
        self.filename=filename
        f = open(filename,"r")
        with f:
            data = f.read()
            # split yaml front matter from content block
            m = splitter.match(data)
            meta = yaml.load(m.group(1))
            for f in ("headline","published","updated","authors","canonical_url","alternate_urls"):
                if f in meta:
                    self.__dict__[f] = meta[f]
                else:
                    if f in ("authors","alternate_urls"):
                        self.__dict__[f] = []
                    else:
                        self.__dict__[f] = None

            # some patchups
            if self.alternate_urls is None:
                self.alternate_urls = []

            self.content = m.group(2)

    def dump(self):
        print("canonical_url: %s" % (self.canonical_url))
        print("headline: %s" % (self.headline))
        print("published: %s" % (self.published))
        print("updated: %s" % (self.updated))
        print("authors: %s" % (self.authors))
        print("------")
        print(self.content)

    def compare(self,expected):
        errs = []

        # check urls
        if self.canonical_url != expected.canonical_url:
            errs.append("canonical_url: expected '%s', got '%s'" %(expected.canonical_url,self.canonical_url))
        if sorted(self.alternate_urls) != sorted(expected.alternate_urls):
            errs.append("alternate_urls: expected '%s', got '%s'" %(expected.alternate_urls,self.alternate_urls))

        # check headline
        if self.headline != expected.headline:
            errs.append("Headline: expected '%s', got '%s'" %(expected.headline,self.headline))

        # check authors
        for author in expected.authors:
            if self.find_author(author) is None:
                errs.append("missing author: '%s'" % (author['name'],))
        for author in self.authors:
            if expected.find_author(author) is None:
                errs.append("extra author: '%s'" % (author['name'],))




        # TODO: everything else :-)

        return errs

    def find_author(self,author):
        for a in self.authors:
            if a['name'] == author['name']:
                return a
        return None

if __name__ == "__main__":
    sys.exit(main())

